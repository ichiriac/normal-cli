const { Command, Flags } = require('@oclif/core');
const fs = require('fs-extra');
const path = require('path');
const chalk = require('chalk');
const { loadConfig, getTimestamp } = require('../../utils/config');

class ModelGenerateCommand extends Command {
  static description = 'Generate a new model';

  static examples = [
    '<%= config.bin %> <%= command.id %> --name User --attributes firstname:string,lastname:string,email:string',
    '<%= config.bin %> <%= command.id %> --name Post --attributes title:string,content:text,author_id:reference',
  ];

  static flags = {
    name: Flags.string({
      char: 'n',
      description: 'Name of the model',
      required: true,
    }),
    attributes: Flags.string({
      char: 'a',
      description: 'Comma-separated list of attributes (e.g., firstname:string,age:integer)',
    }),
    table: Flags.string({
      char: 't',
      description: 'Table name (defaults to lowercase plural of model name)',
    }),
  };

  async run() {
    const { flags } = await this.parse(ModelGenerateCommand);
    const config = await loadConfig();
    const modelsPath = path.resolve(process.cwd(), config.paths.models);

    const modelName = flags.name;
    const tableName = flags.table || this.pluralize(modelName.toLowerCase());
    
    // Parse attributes
    const attributes = [];
    if (flags.attributes) {
      const attrPairs = flags.attributes.split(',');
      for (const pair of attrPairs) {
        const [name, type] = pair.trim().split(':');
        if (name && type) {
          attributes.push({ name, type });
        }
      }
    }

    // Generate model file
    const modelFileName = `${modelName.toLowerCase()}.js`;
    const modelFilePath = path.join(modelsPath, modelFileName);

    if (await fs.pathExists(modelFilePath)) {
      this.error(`Model ${modelName} already exists at ${modelFilePath}`);
    }

    await fs.ensureDir(modelsPath);

    // Build attributes string
    let attributesCode = '';
    for (const attr of attributes) {
      const fieldType = this.mapFieldType(attr.type);
      attributesCode += `    ${attr.name}: ${fieldType},\n`;
    }

    const modelContent = `/**
 * ${modelName} Model
 * Generated by Normal CLI
 */

class ${modelName} {
  static name = '${modelName}';
  static table = '${tableName}';
  static fields = {
    id: 'primary',
${attributesCode}    created_at: { type: 'datetime', default: () => new Date() },
    updated_at: { type: 'datetime', default: () => new Date() },
  };
}

module.exports = ${modelName};
`;

    await fs.writeFile(modelFilePath, modelContent);
    this.log(chalk.green(`✓ Model ${modelName} created at ${modelFilePath}`));

    // Update models/index.js
    const indexPath = path.join(modelsPath, 'index.js');
    if (await fs.pathExists(indexPath)) {
      let indexContent = await fs.readFile(indexPath, 'utf-8');
      
      // Add require statement
      const requireLine = `const ${modelName} = require('./${modelName.toLowerCase()}');`;
      if (!indexContent.includes(requireLine)) {
        // Find the position to insert the require
        const lines = indexContent.split('\n');
        let insertIndex = 0;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes('const ') && lines[i].includes('require(')) {
            insertIndex = i + 1;
          } else if (lines[i].includes('module.exports')) {
            break;
          }
        }
        
        lines.splice(insertIndex, 0, requireLine);
        indexContent = lines.join('\n');
      }
      
      // Add to exports
      if (!indexContent.includes(`${modelName},`)) {
        indexContent = indexContent.replace(
          /module\.exports\s*=\s*{/,
          `module.exports = {\n  ${modelName},`
        );
      }
      
      await fs.writeFile(indexPath, indexContent);
      this.log(chalk.green(`✓ Updated models/index.js`));
    }

    this.log('');
    this.log(chalk.cyan('Next steps:'));
    this.log(`  1. Review and customize the model at ${modelFilePath}`);
    this.log(`  2. Create a migration: normal-cli migration:create --name create-${tableName}-table`);
  }

  pluralize(word) {
    // Simple pluralization
    if (word.endsWith('y')) {
      return word.slice(0, -1) + 'ies';
    } else if (word.endsWith('s') || word.endsWith('x') || word.endsWith('ch') || word.endsWith('sh')) {
      return word + 'es';
    } else {
      return word + 's';
    }
  }

  mapFieldType(type) {
    const typeMap = {
      'string': "'string'",
      'text': "'text'",
      'integer': "'integer'",
      'int': "'integer'",
      'float': "'float'",
      'decimal': "'float'",
      'boolean': "'boolean'",
      'bool': "'boolean'",
      'date': "'date'",
      'datetime': "'datetime'",
      'timestamp': "'datetime'",
      'json': "'json'",
      'reference': "'reference'",
      'enum': "'enum'",
    };

    return typeMap[type.toLowerCase()] || `'${type}'`;
  }
}

module.exports = ModelGenerateCommand;
